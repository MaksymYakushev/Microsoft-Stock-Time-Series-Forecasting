---
title: "Аналіз та прогнозування часових рядів. Лабораторна робота 3"
author: "Якушев Максим"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1 Підготовка даних до роботи

### 1.1 Завантаження даних в R

Переглянемо загальний вигляд завантаженої бази даних. Конвертуємо стовпець Date у формат дати за допомогою функції as.Date()

```{r stock}
stock <- read.csv("Microsoft_Stock.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
stock$Date <- as.Date(stock$Date, tryFormats = c("%Y-%m-%d", "%m/%d/%Y", "%d.%m.%Y"))

print(head(stock))
```

### 1.2 Перевірка, що дані є часовим рядом

Переконаємось, що дані коректно розпізнані: стовпець Date має бути з типом date, а числові показники з типом integer або numeric

```{r}
str(stock)
```

### 1.3 Побудова графіку часового ряду

Побудуємо графік зміни ціни закриття (Close) у часі

```{r}
msft_ts <- ts(stock$Close, frequency = 252, start = c(2015, 1))
plot(msft_ts, type = "l",
     main = "Microsoft Stock Price Over Time",
     ylab = "Closing Price", xlab = "Date", xaxt = "n")

time_values <- time(msft_ts)
year_positions <- seq(2015, 2021, by = 1)
axis(1, at = year_positions, labels = year_positions)
```

# 2 Побудова моделі з використанням спеціальних функцій пакету forecast: holt(), hw(), est()

Підключаємо пакет Forecast

```{r}
library(forecast)
```

Перевіримо чи існує сезонність

```{r}
stl_decomp <- stl(msft_ts, s.window = "periodic")
autoplot(stl_decomp)
```

Як можна побачати з графіка - сезонність присутня.

#### Групування даних по місяцях для побудови моделі

Щоденні дані мають частоту 252 (торгівельні дні на рік), що занадто високо для функцій `hw()`. Тому ми групуємо дані по місяцях та обчислюємо середнє, створюючи часовий ряд з частотою 12 (місяців на рік), що дозволить побудувати моделі

```{r}
library(dplyr)

stock_monthly <- stock %>%
  mutate(Month = format(Date, "%Y-%m")) %>%
  group_by(Month) %>%
  summarise(Close = mean(Close))

msft_ts_monthly <- ts(stock_monthly$Close, frequency = 12, start = c(2015,1))
```

### 2.1 Aдитивна модель Холта – Уінтерса з лінійним трендом

```{r}
hw_additive_model <- hw(msft_ts_monthly, seasonal = "additive")
hw_additive_model$model
```

### 2.2 Адитивна модель Холта – Уінтерса з демпфованим трендом

```{r}
hw_add_damped_model <- hw(msft_ts_monthly, seasonal = "additive", damped = TRUE)
hw_add_damped_model$model
```

### 2.3 Мультиплікативна модель Холта – Уінтерса з лінійним трендом

```{r}
hw_mult_model <- hw(msft_ts_monthly, seasonal = "multiplicative")
hw_mult_model$model
```

### 2.4 Мультиплікативна модель Холта – Уінтерса з демпфованим трендом

```{r}
hw_mult_damped_model <- hw(msft_ts_monthly, seasonal = "multiplicative", damped = TRUE)
hw_mult_damped_model$model
```

### 2.5 ETS-моделі Холта – Уінтерса з адитивними та мультиплікативними помилками

Де:

$A$ - адитивна компонента;

$M$ - мультиплікативна компонента;

$A_d$ - демпфований (damped) тренд.

#### ETS $(A,A,A)$

```{r}
ets_aaa_model <- ets(msft_ts_monthly, model = "AAA")
ets_aaa_model$par 
ets_aaa_model$sigma2
```

#### ETS $(A,A_d,A)$

```{r}
ets_aa_da_model <- ets(msft_ts_monthly, model = "AAA", damped = TRUE)
ets_aa_da_model$par 
ets_aa_da_model$sigma2
```

#### ETS $(M,A,A)$

```{r}
ets_maa_model <- ets(msft_ts_monthly, model = "MAA")
ets_maa_model$par 
ets_maa_model$sigma2
```

#### ETS $(M,A_d,A)$

```{r}
ets_ma_da_model <- ets(msft_ts_monthly, model = "MAA", damped = TRUE)
ets_ma_da_model$par 
ets_ma_da_model$sigma2
```

#### ETS $(M,A,M)$

```{r}
ets_mam_model <- ets(msft_ts_monthly, model = "MAM")
ets_mam_model$par 
ets_mam_model$sigma2
```

#### ETS $(M,A_d,M)$

```{r}
ets_ma_dm_model <- ets(msft_ts_monthly, model = "MAM", damped = TRUE)
ets_ma_dm_model$par 
ets_ma_dm_model$sigma2
```

### Автопідбір моделі за допомогою функції ets()

```{r}
ets_auto <- ets(msft_ts_monthly)
ets_auto$par 
ets_auto$sigma2
```

## 3 Оцінка якості моделей та значень параметрів

Зробимо оцінку розглянутих моделей та порівняємо їх

```{r}
accuracy(hw_additive_model)
accuracy(hw_add_damped_model)
accuracy(hw_mult_model)
accuracy(hw_mult_damped_model)
accuracy(ets_aaa_model)
accuracy(ets_aa_da_model)
accuracy(ets_maa_model)
accuracy(ets_ma_da_model)
accuracy(ets_mam_model)
accuracy(ets_ma_dm_model)
accuracy(ets_auto)
```

#### Таблиця результатів

|   | MAPE | MASE | $\alpha$ | $\beta$ | $\gamma$ | $\varphi$ | $\sigma$ |
|----------------------------------------------|-------|-------|-------|-------|-------|-------|-------|
| **Aдитивна модель Холта – Уінтерса з лінійним трендом** | `r round(accuracy(hw_additive_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(hw_additive_model)["Training set", "MASE"], 3)` | `r round(hw_additive_model$model$par["alpha"], 3)`| `r round(hw_additive_model$model$par["beta"], 3)` | `r round(hw_additive_model$model$par["gamma"], 3)` | - | `r round(sqrt(hw_additive_model$model$sigma), 3)` |
| **Адитивна модель Холта – Уінтерса з демпфованим трендом** | `r round(accuracy(hw_add_damped_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(hw_add_damped_model)["Training set", "MASE"], 3)` | `r round(hw_add_damped_model$model$par["alpha"], 3)`| `r round(hw_add_damped_model$model$par["beta"], 3)` | `r round(hw_add_damped_model$model$par["gamma"], 3)` | `r round(hw_add_damped_model$model$par["phi"], 3)` | `r round(sqrt(hw_add_damped_model$model$sigma), 3)` |
| **Мультиплікативна модель Холта – Уінтерса з лінійним трендом** | `r round(accuracy(hw_mult_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(hw_mult_model)["Training set", "MASE"], 3)` | `r round(hw_mult_model$model$par["alpha"], 3)`| `r round(hw_mult_model$model$par["beta"], 3)` | `r round(hw_mult_model$model$par["gamma"], 3)` | - | `r round(sqrt(hw_mult_model$model$sigma), 3)` |
| **Мультиплікативна модель Холта – Уінтерса з демпфованим трендом** | `r round(accuracy(hw_mult_damped_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(hw_mult_damped_model)["Training set", "MASE"], 3)` | `r round(hw_mult_damped_model$model$par["alpha"], 3)`| `r round(hw_mult_damped_model$model$par["beta"], 3)` | `r round(hw_mult_damped_model$model$par["gamma"], 3)` | `r round(hw_mult_damped_model$model$par["phi"], 3)` | `r round(sqrt(hw_mult_damped_model$model$sigma), 3)` |
| **ETS (A,A,A)** | `r round(accuracy(ets_aaa_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_aaa_model)["Training set", "MASE"], 3)` | `r round(ets_aaa_model$par["alpha"], 3)`| `r round(ets_aaa_model$par["beta"], 3)` | `r round(ets_aaa_model$par["gamma"], 3)` | - | `r round(sqrt(ets_aaa_model$sigma), 3)` |
| **ETS (A,Ad,A)** | `r round(accuracy(ets_aa_da_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_aa_da_model)["Training set", "MASE"], 3)` | `r round(ets_aa_da_model$par["alpha"], 3)`| `r round(ets_aa_da_model$par["beta"], 3)` | `r round(ets_aa_da_model$par["gamma"], 3)` | `r round(ets_aa_da_model$par["phi"], 3)` | `r round(sqrt(ets_aa_da_model$sigma), 3)` |
| **ETS (M,A,A)** | `r round(accuracy(ets_maa_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_maa_model)["Training set", "MASE"], 3)` | `r round(ets_maa_model$par["alpha"], 3)`| `r round(ets_maa_model$par["beta"], 3)` | `r round(ets_maa_model$par["gamma"], 3)` | - | `r round(sqrt(ets_maa_model$sigma), 3)` |
| **ETS (M,Ad,A)** | `r round(accuracy(ets_ma_da_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_ma_da_model)["Training set", "MASE"], 3)` | `r round(ets_ma_da_model$par["alpha"], 3)`| `r round(ets_ma_da_model$par["beta"], 3)` | `r round(ets_ma_da_model$par["gamma"], 3)` | `r round(ets_ma_da_model$par["phi"], 3)` | `r round(sqrt(ets_ma_da_model$sigma), 3)` |
| **ETS (M,A,M)** | `r round(accuracy(ets_mam_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_mam_model)["Training set", "MASE"], 3)` | `r round(ets_mam_model$par["alpha"], 3)`| `r round(ets_mam_model$par["beta"], 3)` | `r round(ets_mam_model$par["gamma"], 3)` | - | `r round(sqrt(ets_mam_model$sigma), 3)` |
| **ETS (M,Ad,M)** | `r round(accuracy(ets_ma_dm_model)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_ma_dm_model)["Training set", "MASE"], 3)` | `r round(ets_ma_dm_model$par["alpha"], 3)`| `r round(ets_ma_dm_model$par["beta"], 3)` | `r round(ets_ma_dm_model$par["gamma"], 3)` | `r round(ets_ma_dm_model$par["phi"], 3)` | `r round(sqrt(ets_ma_dm_model$sigma), 3)` |
| **ETS Auto** | `r round(accuracy(ets_auto)["Training set", "MAPE"], 3)`% | `r round(accuracy(ets_auto)["Training set", "MASE"], 3)` | `r round(ets_auto$par["alpha"], 3)`| `r round(ets_auto$par["beta"], 3)` | - | - | `r round(sqrt(ets_auto$sigma), 3)` |

#### Інтерпретація результатів

Найкращі результати значення **MAPE** показали моделі: ETS Auto - `r round(accuracy(ets_auto)["Training set", "MAPE"], 3)`% та ETS $(M,A,A)$ - `r round(accuracy(ets_maa_model)["Training set", "MAPE"], 3)`%. Взагалі можна сказати, що всі моделі мають приблизно однакові **MAPE** від `r round(accuracy(ets_auto)["Training set", "MAPE"], 3)`% до `r round(accuracy(hw_mult_model)["Training set", "MAPE"], 3)`%. 

Найкращі результати значення **MASE** показали моделі: ETS Auto - `r round(accuracy(ets_auto)["Training set", "MASE"], 3)` та ETS $(M,A,M)$ - `r round(accuracy(ets_mam_model)["Training set", "MASE"], 3)`. Але також, можна сказати, що всі моделі показують дуже близькі значення **MASE** від `r round(accuracy(ets_auto)["Training set", "MASE"], 3)` до `r round(accuracy(ets_aa_da_model)["Training set", "MASE"], 3)`. Це свідчить про їх однакову ефективність відносно наївного методу прогнозування. 

**Коефіцієнта згладжування рівня $\alpha$**. Спостерігається варіативність $\alpha$ від $0.527$ до $1$. Підтверджує необхідність швидкої адаптації до останніх змін у волатильному фінансовому часовому ряді. 

**Коефіцієнт згладжування тренду $\beta$**. Варіюється від $0.042$ до $0.141$. Найвище значення $\beta$ у мультиплікативній моделі з демпфованим трендом свідчить про активне оновлення трендової компоненти, а найменьше значення $\beta$ в інших моделях вказують на відносну стабільність тренду.

**Коефіцієнт сезонності $\gamma$**. Практично всі моделі мають значення $\gamma$ близький до $0$, що свідчить про стабільний сезонний патерн, який не потребує частого оновлення та слабку виражену сезонність у місячних даних акцій Microsoft. Виняток тільки модель ETS $(M,A,M)$ з $\gamma = 0.029$ показує дещо більшу динаміку сезонної компоненти.

**Параметр згасання $\varphi$**. Параметр демпфування присутній у чотирьох моделях зі значеннями від $0.932$ до $0.98$. Високі значення $\varphi$ вказують на повільне затухання тренду.

**Стандартне відхілення $\sigma$**. Найнижні показники $\sigma$ показали моделі: ETS Auto - 0.044; ETS $(M,A,A)$ - 0.047; ETS $(M,A,M)$ - 0.049; ETS $(M,Ad,M)$ - 0.05. Це підтверджує перевагу мультиплікативної структури помилок для фінансових даних. Адитивні моделі мають значно вищі абсолютні значення від $5.941$ до $6.204$.

#### Вибір оптимальної моделі

**Топ-3 моделі:** 1. ETS Auto; 2. ETS $(M,A,A)$; 3. ETS $(M,A,M)$.

## 4 Побудова графіка прогнозу та довірчих інтервалів

Зробимо прогноз використавши отримані моделі (спочатку топ-3 найкращіх моделі, а далі інші). Розділимо дані на навчальні та тестові (тестові 10 % вихідних даних)

```{r}
n <- length(msft_ts_monthly)
test_size <- ceiling(0.1 * n)
train_size <- n - test_size

train <- subset(msft_ts_monthly, end = train_size)
test <- subset(msft_ts_monthly, start = train_size + 1)
```

Навчімо моделі на тренувальних даних

```{r}
# Навчаємо топ-3 моделі 
ets_auto_train <- ets(train)
ets_maa_train <- ets(train, model = "MAA")
ets_mam_train <- ets(train, model = "MAM")

# Інші моделі
hw_add_train <- hw(train, seasonal = "additive")
hw_add_damp_train <- hw(train, seasonal = "additive", damped = TRUE)
hw_mult_train <- hw(train, seasonal = "multiplicative")
hw_mult_damp_train <- hw(train, seasonal = "multiplicative", damped = TRUE)
ets_aaa_train <- ets(train, model = "AAA")
ets_aa_da_train <- ets(train, model = "AAA", damped = TRUE)
ets_ma_da_train <- ets(train, model = "MAA", damped = TRUE)
ets_ma_dm_train <- ets(train, model = "MAM", damped = TRUE)
```

Підключемо пакет ggplot2 для візуалізацій

```{r}
library(ggplot2)
```

### ETS Auto

Зробимо прогноз

```{r}
fc_auto <- forecast(ets_auto_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_auto, series = "Forecast", PI = TRUE) +
  ggtitle("ETS Auto Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_auto, test)
```

### ETS (M,A,A)

Зробимо прогноз

```{r}
fc_maa <- forecast(ets_maa_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_maa, series = "Forecast", PI = TRUE) +
  ggtitle("ETS (M,A,A) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_maa, test)
```

### ETS (M,A,M)

Зробимо прогноз

```{r}
fc_mam <- forecast(ets_mam_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_mam, series = "Forecast", PI = TRUE) +
  ggtitle("ETS (M,A,M) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_mam, test)
```

### Інші моделі

### Aдитивна модель Холта – Уінтерса з лінійним трендом

Зробимо прогноз

```{r}
fc_hw_add <- forecast(hw_add_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_hw_add, series = "Forecast", PI = TRUE) +
  ggtitle("Holt-Winters' Additive Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_hw_add, test)
```

### Адитивна модель Холта – Уінтерса з демпфованим трендом

Зробимо прогноз

```{r}
fc_hw_add_damp <- forecast(hw_add_damp_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_hw_add_damp, series = "Forecast", PI = TRUE) +
  ggtitle("Damped Holt-Winters' Additive Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_hw_add_damp, test)
```

### Мультиплікативна модель Холта – Уінтерса з лінійним трендом

Зробимо прогноз

```{r}
fc_hw_mult <- forecast(hw_mult_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_hw_mult, series = "Forecast", PI = TRUE) +
  ggtitle("Holt-Winters' Multiplicative Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_hw_mult, test)
```

### Мультиплікативна модель Холта – Уінтерса з демпфованим трендом

Зробимо прогноз

```{r}
fc_hw_mult_damp <- forecast(hw_mult_damp_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_hw_mult_damp, series = "Forecast", PI = TRUE) +
  ggtitle("Damped Holt-Winters' Multiplicative Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_hw_mult_damp, test)
```

### ETC (A,A,A)

Зробимо прогноз

```{r}
fc_aaa <- forecast(ets_aaa_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_aaa, series = "Forecast", PI = TRUE) +
  ggtitle("ETC (A,A,A) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_aaa, test)
```

### ETC (A,Ad,A)

Зробимо прогноз

```{r}
fc_aa_da <- forecast(ets_aa_da_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_aa_da, series = "Forecast", PI = TRUE) +
  ggtitle("ETC (A,Ad,A) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_aa_da, test)
```

### ETC (M,Ad,A)

Зробимо прогноз

```{r}
fc_ma_da <- forecast(ets_ma_da_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_ma_da, series = "Forecast", PI = TRUE) +
  ggtitle("ETC (M,Ad,A) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_ma_da, test)
```

### ETC (M,Ad,M)

Зробимо прогноз

```{r}
fc_ma_dm <- forecast(ets_ma_dm_train, h = test_size)
```

Побудуємо графік пронозу

```{r}
autoplot(train) +
  autolayer(test, series = "Test Data") +
  autolayer(fc_ma_dm, series = "Forecast", PI = TRUE) +
  ggtitle("ETC (M,Ad,M) Forecast") +
  ylab("Closing Price") + xlab("Time")
```

Оцінимо точність прогнозу

```{r}
accuracy(fc_ma_dm, test)
```

### Оцінка якості прогнозу

Отримали таку таблицю

|   | MAPE (train) | MASE (train) | MAPE (test) | MASE (test) |
|---------------------------------------------|------|------|------|------|
| **ETS Auto** | `r round(accuracy(fc_auto, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_auto, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_auto, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_auto, test)["Test set", "MASE"], 3)` |
| **ETS (M,A,A)** | `r round(accuracy(fc_maa, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_maa, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_maa, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_maa, test)["Test set", "MASE"], 3)` |
| **ETS (M,A,M)** | `r round(accuracy(fc_mam, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_mam, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_mam, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_mam, test)["Test set", "MASE"], 3)` |
| **Aдитивна модель Холта – Уінтерса з лінійним трендом** | `r round(accuracy(fc_hw_add, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_add, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_hw_add, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_add, test)["Test set", "MASE"], 3)` |
| **Адитивна модель Холта – Уінтерса з демпфованим трендом** | `r round(accuracy(fc_hw_add_damp, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_add_damp, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_hw_add_damp, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_add_damp, test)["Test set", "MASE"], 3)` |
| **Мультиплікативна модель Холта – Уінтерса з лінійним трендом** | `r round(accuracy(fc_hw_mult, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_mult, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_hw_mult, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_mult, test)["Test set", "MASE"], 3)` |
| **Мультиплікативна модель Холта – Уінтерса з демпфованим трендом** | `r round(accuracy(fc_hw_mult_damp, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_mult_damp, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_hw_mult_damp, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_hw_mult_damp, test)["Test set", "MASE"], 3)` |
| **ETS (A,A,A)** | `r round(accuracy(fc_aaa, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_aaa, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_aaa, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_aaa, test)["Test set", "MASE"], 3)` |
| **ETS (A,Ad,A)** | `r round(accuracy(fc_aa_da, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_aa_da, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_aa_da, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_aa_da, test)["Test set", "MASE"], 3)` |
| **ETS (M,Ad,A)** | `r round(accuracy(fc_ma_da, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_ma_da, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_ma_da, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_ma_da, test)["Test set", "MASE"], 3)` |
| **ETS (M,Ad,M)** | `r round(accuracy(fc_ma_dm, test)["Training set", "MAPE"], 3)`% | `r round(accuracy(fc_ma_dm, test)["Training set", "MASE"], 3)` | `r round(accuracy(fc_ma_dm, test)["Test set", "MAPE"], 3)`% | `r round(accuracy(fc_ma_dm, test)["Test set", "MASE"], 3)` |

### Ключові спостереження

- Усі моделі з мультиплікативними помилками (M) показали кращі результати на тестових даних порівняно з адитивними.

- Модель **ETS Auto**, яка показала найкращі результати на навчальній вибірці MAPE (train) = $3.277\%$, на тестових даних має гірші показники MAPE (test)  = $3.528\%$.

- Моделі без сезонної компоненти програють моделям з сезонністю.

- Оптимальною моделлю є: **ETS (M,A,M)** - Модель з мультиплікативними помилками, адитивним трендом та мультиплікативною сезонністю.

## 5 Побудова графіка вихідного та згладженого часового ряду

Побудуємо графіки вихідного та згладженого часового ряду для найкращих моделей

### ETS Auto

```{r}
autoplot(msft_ts_monthly, series = "Original Series") +
  autolayer(fitted(ets_auto), series = "Fitted Value") +
  ggtitle("Original and Fitted Time Series - ETS Auto") +
  ylab("Closing Price") + xlab("Time")
```

### ETS (M,A,A)

```{r}
autoplot(msft_ts_monthly, series = "Original Series") +
  autolayer(fitted(ets_maa_model), series = "Fitted Value") +
  ggtitle("Original and Fitted Time Series - ETS (M,A,A)") +
  ylab("Closing Price") + xlab("Time")
```

### ETS (M,A,M)

```{r}
autoplot(msft_ts_monthly, series = "Original Series") +
  autolayer(fitted(ets_mam_model), series = "Fitted Value") +
  ggtitle("Original and Fitted Time Series - ETS (M,A,M)") +
  ylab("Closing Price") + xlab("Time")
```

## 6 Побудова графіків окремих компонентів часового ряду

### ETS Auto

Побудуємо графік окремих компонентів часового ряду

```{r}
autoplot(ets_auto)
```

На графіку компонента **observed** - це вихідний часовий ряд, **level** - компонента рівня, **slope** - тренд (нахил). Можна побачити різкий стрибок нахилу в ковідні часи. Велике значення $\alpha = 1$ призвело до того, що графік згладженого рівня майже ідентичний графіку вихідного тимчасового ряду.

Побудуємо тепер графіки залишків моделі

```{r}
cbind('Residuals' = residuals(ets_auto),
'Forecast errors' = residuals(ets_auto, type='response')) %>%
autoplot(facet=TRUE) + xlab("Time") + ylab("Closing Price")
```

Зауважимо, що у разі мультиплікативних помилок залишки моделі та помилки прогнозу неідентичні. Графік це показує.

### ETS $(M,A,A)$

Побудуємо графік окремих компонентів часового ряду

```{r}
autoplot(ets_maa_model)
```

На графіку бачимо такі ж самі компоненти: **observed**,  **level**, **slope**. До них ще додається компанента **season**, яка відображає сезонні коливання.

Побудуємо графік окремих компонентів часового ряду

```{r}
cbind('Residuals' = residuals(ets_maa_model),
'Forecast errors' = residuals(ets_maa_model, type='response')) %>%
autoplot(facet=TRUE) + xlab("Time") + ylab("Closing Price")
```

### ETS $(M,A,M)$

Побудуємо графік окремих компонентів часового ряду

```{r}
autoplot(ets_mam_model)
```

На графіку бачимо такі ж самі компоненти: **observed**,  **level**, **slope**, **season**.

Побудуємо графік окремих компонентів часового ряду

```{r}
cbind('Residuals' = residuals(ets_mam_model),
'Forecast errors' = residuals(ets_mam_model, type='response')) %>%
autoplot(facet=TRUE) + xlab("Time") + ylab("Closing Price")
```

## Висновок

Було побудовано 11 різних моделей експоненційного згладжування: чотири варіанти моделей Холта-Уінтерса (адитивна та мультиплікативна, з лінійним та демпфованим трендом), шість специфікованих ETS-моделей та одна автоматично підібрана модель. Було проведено навчання моделей та прогнозування. На повному наборі даних найкращі результати показали моделі з мультиплікативними помилками ETS Auto, ETS(M,A,A) та ETS(M,A,M). Це підтвердило, що для фінансових даних з високою волатильністю мультиплікативна структура помилок є більш адекватною. Декомпозиція часових рядів показала наявність чітко вираженого зростаючого тренду з різким стрибком у 2020 році. 

Для прогнозування цін акцій Microsoft рекомендується використовувати модель ETS (M,A,M) з мультиплікативними помилками, адитивним трендом та мультиплікативною сезонністю. Ця модель демонструє найкращу узагальнюючу здатність (MAPE на тестових даних на $1\%$ нижчий, ніж на навчальних) та найвищу точність прогнозування серед усіх розглянутих варіантів.
